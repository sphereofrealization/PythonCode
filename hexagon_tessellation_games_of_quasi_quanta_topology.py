# -*- coding: utf-8 -*-
"""Hexagon Tessellation Games of Quasi-Quanta Topology.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1n7F2MMnnidIpOPBGPLi8tyL9OiffAqjU
"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import networkx as nx

# Define a safe division function to avoid division by zero
def safe_divide(num, den):
    if np.abs(den) < 1e-10:
        return 0
    return num / den

# Functions f1 and f2 corrected for divide by zero
def f1(theta):
    if np.abs(theta) < 1e-10:  # Close to zero
        return 0
    return np.arcsin(np.sin(theta)) + (np.pi / 2) * (1 - safe_divide(np.pi, (2 * theta)))

def f2(theta):
    if np.abs(theta) < 1e-10:  # Close to zero
        return 0
    return np.arcsin(np.cos(theta)) + (np.pi / 2) * (1 - safe_divide(np.pi, (2 * theta)))

# Define decision graph for logic modulation
def create_decision_graph():
    G = nx.DiGraph()
    # Define logical nodes for quantifiers and logic operations
    logical_nodes = ['phi_eq_psi', 'some_other_node']  # Adjust as needed
    for node in logical_nodes:
        G.add_node(node, value=np.random.rand())  # Assign random values for demonstration
    return G

G = create_decision_graph()

# Define a logic vector calculation
def logic_vector(G, node_name):
    # Placeholder function, retrieves the assigned 'value' attribute from the node
    return G.nodes[node_name]['value']

# Tessellation visualization (corrected)
def visualize_tessellation(G, domain, hex_centers, hex_size):
    fig, ax = plt.subplots()

    # Loop through each hexagon center
    for center in hex_centers:
        x, y = center
        theta = np.arctan2(y, x)
        efficiency_value = f1(theta) * f2(theta)  # Combine f1 and f2

        # Fetch value from decision graph
        decision_value = logic_vector(G, 'phi_eq_psi')

        # Adjust efficiency based on decision value
        adjusted_efficiency = efficiency_value * decision_value

        # Create and draw hexagon
        hexagon = patches.RegularPolygon(center, numVertices=6, radius=hex_size, orientation=np.pi/6)
        color_value = adjusted_efficiency  # Map this to a valid color range if necessary

        # Set color and add hexagon patch to the plot
        hexagon.set_facecolor(plt.cm.viridis(color_value))
        ax.add_patch(hexagon)

    ax.set_xlim(domain[0], domain[1])
    ax.set_ylim(domain[2], domain[3])
    ax.set_aspect('equal')  # Equal aspect ratio for x and y dimensions
    plt.axis('off')  # Turn off axis lines and labels
    plt.show()

# Define the domain and hexagon center grid
domain = (-5, 5, -5, 5)  # Domain for plotting
hex_size = 0.5  # Size of hexagons

# Construct hexagon centers
hex_centers = [(i, j) for i in np.arange(domain[0] + hex_size, domain[1], 3*hex_size * np.sqrt(3)/2)
                       for j in np.arange(domain[2] + hex_size, domain[3], 3*hex_size)]

# Check if we're on an even row to create the staggered hexagonal lattice
for i, center in enumerate(hex_centers):
    if int((center[1] - domain[2]) / (3 * hex_size)) % 2 == 0:
        hex_centers[i] = (center[0] + (1.5 * hex_size * (3/2)), center[1])

# Visualize the tessellated surface
visualize_tessellation(G, domain, hex_centers, hex_size)

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import sympy as sp
import networkx as nx

# Constants
theta_inf = 2 * np.pi
r = 0.5

# Functions f1 and f2
def f1(theta):
    if theta == 0:
        return np.pi / 2
    return np.arcsin(np.sin(theta)) + (np.pi / 2) * (1 - np.pi / (2 * theta))

def f2(theta):
    if theta == 0:
        return np.pi / 2
    return np.arcsin(np.cos(theta)) + (np.pi / 2) * (1 - np.pi / (2 * theta))

# Define decision graph for logic modulation
def create_decision_graph():
    G = nx.DiGraph()
    logical_nodes = ['psi_1', 'psi_2', 'omega', 'phi']
    for node in logical_nodes:
        G.add_node(node, value=np.random.rand())
    return G

# Logic vector and logic operations
def update_logic_vector(G, logic_expr):
    G.nodes['phi']['value'] = logic_expr  # Update the logic value based on user input

# Function to randomly update the logic values for demonstration purposes
def random_logic_update(G):
    for node in G:
        G.nodes[node]['value'] = np.random.rand()

# Tessellation visualization
def visualize_tessellation(G, domain, hex_centers, hex_size):
    plt.ion()
    fig, ax = plt.subplots()
    for center in hex_centers:
        x, y = center
        theta = np.arctan2(y, x) if x != 0 else np.pi / 2
        efficiency_value = f1(theta) * f2(theta)
        logic_values = [G.nodes[node]['value'] for node in G]
        decision_value = np.mean(logic_values)
        adjusted_efficiency = efficiency_value * decision_value
        hexagon = patches.RegularPolygon(center, numVertices=6, radius=hex_size, orientation=np.pi/6)
        color_value = np.clip(adjusted_efficiency, 0, 1)
        hexagon.set_facecolor(plt.cm.viridis(color_value))
        ax.add_patch(hexagon)
    ax.set_xlim(domain[0], domain[1])
    ax.set_ylim(domain[2], domain[3])
    ax.set_aspect('equal')
    plt.axis('off')
    plt.show()

# Domain and hexagon size for tessellation
domain = (-5, 5, -5, 5)
hex_size = 0.5

# Construct hexagon centers
hex_centers = [(i, j) for i in np.arange(domain[0], domain[1], hex_size)
               for j in np.arange(domain[2], domain[3], hex_size)]

# Create decision graph with random node values
G = create_decision_graph()

# Simulation loop
for _ in range(16):  # Simulate user input and updating the graph 3 times
    # Randomly update the logic values
    random_logic_update(G)
    # Re-visualize the updated tessellation
    visualize_tessellation(G, domain, hex_centers, hex_size)
    plt.pause(1)  # Pause for visual effect

plt.ioff()  # Turn off interactive mode
plt.show()

import ipywidgets as widgets
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as patches
from IPython.display import clear_output

# Define the function influenced by the symbolic formula
Omega = 2.0  # Just an example global scaling factor
epsilon = 1e-8  # Small constant to avoid division by zero

def symbolic_function(x, y, t):
    # Avoid division by zero at the origin
    nabla = np.sqrt(x**2 + y**2) if x**2 + y**2 > 0 else epsilon

    # Interpreting Delta as differences/deltas in x and y
    Delta_x = np.cos(x + t)
    Delta_y = np.sin(y + t)

    # Combining the symbolic operations using creative interpretations
    result = Omega * (Delta_x * complex(0, 1) + Delta_y / nabla) * \
            ((np.sin(x * y * Omega * t) * nabla) + Delta_x / (complex(0, 1) + 1 / nabla))
    return result.real  # Take real part to get a value we can map to colors

# Tessellation parameters
domain = (-5, 5, -5, 5)
hex_size = 0.5
hex_centers = [(i, j) for i in np.arange(domain[0], domain[1], hex_size)
               for j in np.arange(domain[2], domain[3], hex_size)]

# Widget for time control
t_slider = widgets.FloatSlider(value=0, min=0, max=50, step=0.1, description="Time", continuous_update=False)

@widgets.interact(t=t_slider)
def update_visualizations_symbolic(t):
    clear_output(wait=True)
    fig, ax = plt.subplots(figsize=(10, 10))

    # Map color scale from -1 to 1 to [0, 1] for colormap compatibility
    color_min, color_max = -1, 1

    # Create tessellation pattern with colors based on the 'symbolic_function'
    for center in hex_centers:
        x, y = center
        color_value = symbolic_function(x, y, t)
        # Scale color_value to the 0-1 range for colormap
        color_value_normalized = (color_value - color_min) / (color_max - color_min)
        hexagon = patches.RegularPolygon(center, numVertices=6, radius=hex_size, orientation=np.pi/6)
        hexagon.set_facecolor(plt.cm.viridis(color_value_normalized))
        ax.add_patch(hexagon)

    ax.set_xlim(domain[0], domain[1])
    ax.set_ylim(domain[2], domain[3])
    ax.set_aspect('equal')
    plt.axis('off')
    plt.show()

# Display the widget
display(t_slider)

import ipywidgets as widgets
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as patches
from IPython.display import clear_output

# Define the function influenced by the symbolic formula
Omega = 2.0  # Just an example of a scaling factor
epsilon = 1e-10  # Small number to prevent division by zero

def symbolic_function(x, y, t):
    # Calculate 'nabla' with a safety for division by zero at the origin (0,0)
    nabla = np.sqrt(x**2 + y**2) if x**2 + y**2 > 0 else epsilon

    # Calculate Delta_x and Delta_y with time variation
    Delta_x = np.cos(x + t)
    Delta_y = np.sin(y + t)

    # Symbolic expression interpretation with complex numbers
    # The operations have been creatively interpreted for demonstration purposes
    result = Omega * (Delta_x * complex(0, 1) + Delta_y / nabla) *\
             ((np.sin(x * y * Omega * t) * nabla) + Delta_x / (complex(0, 1) + 1 / nabla))
    # Return the absolute value to get a positive value for color mapping
    return abs(result.real)

# Tessellation parameters
domain = (-5, 5, -5, 5)
hex_size = 0.5
hex_centers = [(i, j) for i in np.arange(domain[0], domain[1], hex_size)
               for j in np.arange(domain[2], domain[3], hex_size)]

# Widget for time control
t_slider = widgets.FloatSlider(value=0, min=0, max=50, step=0.1, description="Time", continuous_update=False)

# Main update function for the visualization
@widgets.interact(t=t_slider)
def update_visualizations_normalized(t):
    clear_output(wait=True)
    fig, ax = plt.subplots(figsize=(10, 10))

    # Create tessellation pattern with colors based on the symbolic_function
    color_values = np.array([symbolic_function(x, y, t) for x, y in hex_centers])
    # Normalize color values to [0, 1] range
    color_min, color_max = np.min(color_values), np.max(color_values)
    color_values_normalized = (color_values - color_min) / (color_max - color_min)

    for i, center in enumerate(hex_centers):
        hexagon = patches.RegularPolygon(center, numVertices=6, radius=hex_size, orientation=np.pi/6)
        hexagon.set_facecolor(plt.cm.viridis(color_values_normalized[i]))
        ax.add_patch(hexagon)

    # Set properties for the plot
    ax.set_xlim(domain[0], domain[1])
    ax.set_ylim(domain[2], domain[3])
    ax.set_aspect('equal')
    plt.axis('off')
    plt.show()

# Display the widget
display(t_slider)

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import ipywidgets as widgets
from IPython.display import clear_output

# Imaginatively define some of the custom symbols with parameters and functions
Omega = 2.0
gamma = 0.9
A_circle = 1.0
i_const = 1.0
heart_factor = np.random.rand()

# Custom function that interprets the expression for a given (x, y)
def interpret_quasi_quanta(x, y, t):
    # Add some randomness to the color variation
    random_effect = heart_factor * np.random.uniform(0.8, 1.2)

    # Calculate a difference representing Delta and Nabla as a distance from center
    distance = np.sqrt(x**2 + y**2)
    delta = np.abs(x - y)

    # Harmonic operations as a combination of sines and cosines
    harmonic = np.sin(Omega * distance * t) + np.cos(gamma * t)

    # Simulate the complex formula by combining terms in a creative way
    result = harmonic * delta * A_circle / (i_const + random_effect) * random_effect
    return result

# Tessellation parameters
domain = (-5, 5, -5, 5)
hex_size = 0.5
hex_centers = [(i, j) for i in np.arange(domain[0], domain[1], hex_size)
               for j in np.arange(domain[2], domain[3], hex_size)]

# Widget for time control
t_slider = widgets.FloatSlider(value=0, min=0, max=50, step=0.1, description="Time", continuous_update=False)

# Visualization function that applies the interpretive quasi-quanta function
@widgets.interact(t=t_slider)
def update_visualizations_quasi(t):
    clear_output(wait=True)
    fig, ax = plt.subplots(figsize=(10, 10))

    # Calculate color values based on quasi-quanta function interpretation
    color_values = np.array([interpret_quasi_quanta(x, y, t) for x, y in hex_centers])
    # Normalize color values to [0, 1] range
    color_min, color_max = color_values.min(), color_values.max()
    color_values_normalized = (color_values - color_min) / (color_max - color_min)

    # Plot the tessellation and fill hexagons based on the color values
    for idx, center in enumerate(hex_centers):
        hexagon = patches.RegularPolygon(center, numVertices=6, radius=hex_size, orientation=np.pi/6)
        hexagon.set_facecolor(plt.cm.viridis(color_values_normalized[idx]))
        ax.add_patch(hexagon)

    # Finalize plot settings
    ax.set_xlim(domain[0], domain[1])
    ax.set_ylim(domain[2], domain[3])
    ax.set_aspect('equal')
    plt.axis('off')
    plt.show()

# Display the widget
display(t_slider)

import ipywidgets as widgets
from IPython.display import display
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import sympy as sp
import networkx as nx

# Initialize domain and hex centers for the tessellation
domain = (-5, 5, -5, 5)
hex_size = 0.5
hex_centers = [(i, j) for i in np.arange(domain[0], domain[1], hex_size) for j in np.arange(domain[2], domain[3], hex_size)]

# Define sliders for radius and number of hexagons
R_slider = widgets.FloatSlider(value=5, min=1, max=10, step=0.5, description="Radius (m)")
num_hex_slider = widgets.IntSlider(value=10, min=1, max=100, step=1, description="Number of Hexagons")

# Function to create the tessellation visualization
def visualize_tessellation(R, num_hex):
    fig, ax = plt.subplots()
    # Calculate the position and radius of the central hexagon
    central_hexagon_position = (0, 0)
    central_hexagon_radius = R
    # Draw the central hexagon
    central_hexagon = patches.RegularPolygon(central_hexagon_position, numVertices=6,
                                             radius=central_hexagon_radius,
                                             orientation=np.pi / 6)
    central_hexagon.set_facecolor('red')
    ax.add_patch(central_hexagon)

    # Calculate the positions and radii of the surrounding hexagons
    hex_positions = [(central_hexagon_position[0] + R * np.cos(2 * np.pi / num_hex * k),
                      central_hexagon_position[1] + R * np.sin(2 * np.pi / num_hex * k))
                     for k in range(1, num_hex + 1)]
    hex_radii = [R / np.sqrt(3) for _ in range(num_hex)]

    # Add the surrounding hexagons to the plot
    for pos, radius in zip(hex_positions, hex_radii):
        hexagon = patches.RegularPolygon(pos, numVertices=6, radius=radius, orientation=np.pi / 6)
        ax.add_patch(hexagon)

    # Adjust the layout or structure of the graph based on the current x and y positions
    # of the particle on the time compass
    # The layout can be influenced by current_x_pos and current_y_pos
    # For example, we can use these values to determine the size or layout of the hexagons

    ax.set_xlim(domain[0], domain[1])
    ax.set_ylim(domain[2], domain[3])
    ax.set_aspect('equal')
    plt.axis('off')

    # Display the plot
    plt.show()

# Function to create the time compass visualization
def visualize_circle(R, num_hex):
    fig, ax = plt.subplots()

    # Draw circle and plot the current position of the particle
    circle = plt.Circle((0, 0), R, color='blue', fill=False)
    ax.add_artist(circle)

    # Update tessellation based on current values
    visualize_tessellation(R, num_hex)

    ax.set_xlabel("x (m)")
    ax.set_ylabel("y (m)")
    ax.set_xlim(-R * 1.5, R * 1.5)
    ax.set_ylim(-R * 1.5, R * 1.5)
    ax.set_aspect('equal')

    # Display the plot
    plt.show()

# Link sliders to visualization function
widgets.interactive(visualize_circle, R=R_slider, num_hex=num_hex_slider)

import ipywidgets as widgets
from IPython.display import display
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import sympy as sp
import networkx as nx

# Define the functions required for the tessellation pattern
def f1(theta):
    if theta == 0:
        return np.pi / 2
    return np.arcsin(np.sin(theta)) + (np.pi / 2) * (1 - np.pi / (2 * theta))

def f2(theta):
    if theta == 0:
        return np.pi / 2
    return np.arcsin(np.cos(theta)) + (np.pi / 2) * (1 - np.pi / (2 * theta))

# Initialize domain and hex centers for the tessellation
domain = (-5, 5, -5, 5)
hex_size = 0.5
hex_centers = [(i, j) for i in np.arange(domain[0], domain[1], hex_size) for j in np.arange(domain[2], domain[3], hex_size)]

# Define sliders for time, radius and angular velocity
t_slider = widgets.FloatSlider(value=0, min=0, max=100, step=0.1, description="Time (s)")
R_slider = widgets.FloatSlider(value=5, min=1, max=10, step=0.5, description="Radius (m)")
omega_slider = widgets.FloatSlider(value=2 * np.pi, min=0, max=4 * np.pi, step=0.1 * np.pi, description="Ang. Vel. (rad/s)")

# Function to create the tessellation visualization
def visualize_tessellation(t, R, omega):
    fig, ax = plt.subplots()
    for center in hex_centers:
        x, y = center
        theta = np.arctan2(y, x) if x != 0 else np.pi / 2
        efficiency_value = f1(theta) * f2(theta) * (1 - f1(theta)) * (1 - f2(theta))
        color_value = np.clip(efficiency_value * np.sin(omega * t), 0, 1)
        hexagon = patches.RegularPolygon((x, y), numVertices=6, radius=hex_size, orientation=np.pi/6)
        hexagon.set_facecolor(plt.cm.viridis(color_value))
        ax.add_patch(hexagon)

    # Adjust the layout or structure of the graph based on the current x and y positions
    # of the particle on the time compass
    current_x_pos = R * np.cos(omega * t)
    current_y_pos = R * np.sin(omega * t)
    # The layout can be influenced by current_x_pos and current_y_pos
    # For example, we can use these values to determine the size or layout of the hexagons

    ax.set_xlim(domain[0], domain[1])
    ax.set_ylim(domain[2], domain[3])
    ax.set_aspect('equal')
    plt.axis('off')

    # Display the plot
    plt.show()

# Function to create the time compass visualization
def visualize_circular_motion(t, R, omega):
    fig, ax = plt.subplots()

    # Draw circle and plot the current position of the particle
    circle = plt.Circle((0, 0), R, color='blue', fill=False)
    ax.add_artist(circle)

    x_path = R * np.cos(omega * np.linspace(0, t, 100))
    y_path = R * np.sin(omega * np.linspace(0, t, 100))
    ax.plot(x_path, y_path, color='gray', linestyle='--')

    current_x_pos = R * np.cos(omega * t)
    current_y_pos = R * np.sin(omega * t)
    ax.arrow(0, 0, current_x_pos, current_y_pos, head_width=R/20, head_length=R/15, fc='red', ec='red')
    ax.scatter(current_x_pos, current_y_pos, color='red')

    ax.set_xlabel("x (m)")
    ax.set_ylabel("y (m)")
    ax.set_xlim(-R * 1.5, R * 1.5)
    ax.set_ylim(-R * 1.5, R * 1.5)
    ax.set_aspect('equal')

    # Update tessellation based on current values
    visualize_tessellation(t, R, omega)

    # Display the plot
    plt.show()

# Link sliders to visualization function
widgets.interactive(visualize_circular_motion, t=t_slider, R=R_slider, omega=omega_slider)